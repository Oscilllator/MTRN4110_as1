function [point, normal] = getOrientation(p)
    x = p(:, :, 1);
    y = p(:, :, 2);
    z = p(:, :, 3);

    %pretty sure this just turns the data from a 2x2 matrix into a vector
    [xData, yData, zData] = prepareSurfaceData( x, y, z );
    [fitresult, gof] = fit( [xData, yData], zData, 'poly11');

    %plane is of the form:
    %z = p00 + p10*x + p01*y
    %I like the form:
    %a*x + b*y + c*z = d
    a = fitresult.p10;
    b = fitresult.p01;
    c = 1;
    d = fitresult.p00;

    %now fit the data back, should be more or less the same as
    %the previos p and n: (the direction of n, not the magnitude)
    normal = [a b -c];

    %find a point more or less in the middle of the plane:
    [xLen, yLen, ~] = size(p);
    planePt = squeeze(p(round(xLen/2), round(yLen/2), :));
    %refit z point to be inline with the values generated by the curve fit:
    point = [planePt(1) planePt(2) (-d - a*planePt(1) - b*planePt(2))/-c];
    
end