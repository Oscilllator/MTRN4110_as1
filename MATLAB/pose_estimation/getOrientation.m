function [point, normal, fitresult] = getOrientation(p)

    %pretty sure this just turns the x, y and z data into 3 vectors instead
    %of matrices
    [xData, yData, zData] = prepareSurfaceData( p(:, :, 1), p(:, :, 2), p(:, :, 3) );
    [fitresult, gof] = fit( [xData, yData], zData, 'poly11');

    %plane is of the form:
    %z = p00 + p10*x + p01*y
    %I like the form:
    %a*x + b*y + c*z = d
    a = fitresult.p10;
    b = fitresult.p01;
    c = 1;
    d = fitresult.p00;

    %now fit the data back, should be more or less the same as
    %the previos p and n: (the direction of n, not the magnitude)
    normal = [a b -c];

    %find a point more or less in the middle of the plane:
    [xLen, yLen, ~] = size(p);
    planePt = squeeze(p(round(xLen/2), round(yLen/2), :));
    %refit z point to be inline with the values generated by the curve fit:
    point = [planePt(1) planePt(2) (-d - a*planePt(1) - b*planePt(2))/-c];
    
end